[{"title":"HttpURLConnection中文地址请求乱码","date":"2017-08-31T08:00:14.000Z","path":"2017/08/31/HttpURLConnection中文地址请求乱码/","text":"天气终于不热了 不多说,今天碰到一个问题,HttpURLConnection中文乱码. 下面是初始代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255package com.work.api.base;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStream;import java.io.OutputStreamWriter;import java.net.HttpURLConnection;import java.net.InetSocketAddress;import java.net.Proxy;import java.net.URL;import java.net.URLConnection;import java.util.Iterator;import java.util.Map;/** * * @author 治疗术 * @Date：2017年8月31日 下午1:05:54 * @Description: TODO(...) * @version */public class HttpRequestor &#123; private String charset = \"utf-8\"; private Integer connectTimeout = null; private Integer socketTimeout = null; private String proxyHost = null; private Integer proxyPort = null; /** * Do GET request * @param url * @return * @throws Exception * @throws IOException */ public String doGet(String url) throws Exception &#123; URL localURL = new URL(url); URLConnection connection = openConnection(localURL); HttpURLConnection httpURLConnection = (HttpURLConnection)connection; httpURLConnection.setRequestProperty(\"Accept-Charset\", charset); httpURLConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); InputStream inputStream = null; InputStreamReader inputStreamReader = null; BufferedReader reader = null; StringBuffer resultBuffer = new StringBuffer(); String tempLine = null; if (httpURLConnection.getResponseCode() &gt;= 300) &#123; throw new Exception(\"HTTP Request is not success, Response code is \" + httpURLConnection.getResponseCode()); &#125; try &#123; inputStream = httpURLConnection.getInputStream(); inputStreamReader = new InputStreamReader(inputStream); reader = new BufferedReader(inputStreamReader); while ((tempLine = reader.readLine()) != null) &#123; resultBuffer.append(tempLine); &#125; &#125; finally &#123; if (reader != null) &#123; reader.close(); &#125; if (inputStreamReader != null) &#123; inputStreamReader.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; &#125; return resultBuffer.toString(); &#125; /** * Do POST request * @param url * @param parameterMap * @return * @throws Exception */ public String doPost(String url, Map parameterMap) throws Exception &#123; /* Translate parameter map to parameter date string */ StringBuffer parameterBuffer = new StringBuffer(); if (parameterMap != null) &#123; Iterator iterator = parameterMap.keySet().iterator(); String key = null; String value = null; while (iterator.hasNext()) &#123; key = (String)iterator.next(); if (parameterMap.get(key) != null) &#123; value = (String)parameterMap.get(key); &#125; else &#123; value = \"\"; &#125; parameterBuffer.append(key).append(\"=\").append(value); if (iterator.hasNext()) &#123; parameterBuffer.append(\"&amp;\"); &#125; &#125; &#125; System.out.println(\"POST parameter : \" + parameterBuffer.toString()); URL localURL = new URL(url); URLConnection connection = openConnection(localURL); HttpURLConnection httpURLConnection = (HttpURLConnection)connection; httpURLConnection.setDoOutput(true); httpURLConnection.setRequestMethod(\"POST\"); httpURLConnection.setRequestProperty(\"Accept-Charset\", charset); httpURLConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\"); httpURLConnection.setRequestProperty(\"Content-Length\", String.valueOf(parameterBuffer.length())); OutputStream outputStream = null; OutputStreamWriter outputStreamWriter = null; InputStream inputStream = null; InputStreamReader inputStreamReader = null; BufferedReader reader = null; StringBuffer resultBuffer = new StringBuffer(); String tempLine = null; try &#123; outputStream = httpURLConnection.getOutputStream(); outputStreamWriter = new OutputStreamWriter(outputStream); outputStreamWriter.write(parameterBuffer.toString()); outputStreamWriter.flush(); if (httpURLConnection.getResponseCode() &gt;= 300) &#123; throw new Exception(\"HTTP Request is not success, Response code is \" + httpURLConnection.getResponseCode()); &#125; inputStream = httpURLConnection.getInputStream(); inputStreamReader = new InputStreamReader(inputStream); reader = new BufferedReader(inputStreamReader); while ((tempLine = reader.readLine()) != null) &#123; resultBuffer.append(tempLine); &#125; &#125; finally &#123; if (outputStreamWriter != null) &#123; outputStreamWriter.close(); &#125; if (outputStream != null) &#123; outputStream.close(); &#125; if (reader != null) &#123; reader.close(); &#125; if (inputStreamReader != null) &#123; inputStreamReader.close(); &#125; if (inputStream != null) &#123; inputStream.close(); &#125; &#125; return resultBuffer.toString(); &#125; private URLConnection openConnection(URL localURL) throws IOException &#123; URLConnection connection; if (proxyHost != null &amp;&amp; proxyPort != null) &#123; Proxy proxy = new Proxy(Proxy.Type.HTTP, new InetSocketAddress(proxyHost, proxyPort)); connection = localURL.openConnection(proxy); &#125; else &#123; connection = localURL.openConnection(); &#125; return connection; &#125; /** * Render request according setting * @param request */ private void renderRequest(URLConnection connection) &#123; if (connectTimeout != null) &#123; connection.setConnectTimeout(connectTimeout); &#125; if (socketTimeout != null) &#123; connection.setReadTimeout(socketTimeout); &#125; &#125; /* * Getter &amp; Setter */ public Integer getConnectTimeout() &#123; return connectTimeout; &#125; public void setConnectTimeout(Integer connectTimeout) &#123; this.connectTimeout = connectTimeout; &#125; public Integer getSocketTimeout() &#123; return socketTimeout; &#125; public void setSocketTimeout(Integer socketTimeout) &#123; this.socketTimeout = socketTimeout; &#125; public String getProxyHost() &#123; return proxyHost; &#125; public void setProxyHost(String proxyHost) &#123; this.proxyHost = proxyHost; &#125; public Integer getProxyPort() &#123; return proxyPort; &#125; public void setProxyPort(Integer proxyPort) &#123; this.proxyPort = proxyPort; &#125; public String getCharset() &#123; return charset; &#125; public void setCharset(String charset) &#123; this.charset = charset; &#125; &#125; 在使用get方法的时候请求url含有中文(心跳.jpg),结果报错.这个时候就比较迷茫了1httpURLConnection.setRequestProperty(\"Accept-Charset\", charset); 设置过编码了啊!怎么还是会出错了?然后经过很久的思考(Google)…….发现只要1URL localURL = new URL(url); 改成1URL localURL = new URI(url).toASCIIString(); 就行了转成ASCII 后来发现其实是传进来的地址编码跟文件服务器的编码不一致导致的,只是转成ASCII是通用一点. 路漫漫","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://aschouas.com/categories/JAVA/"}],"tags":[{"name":"技术研究","slug":"技术研究","permalink":"http://aschouas.com/tags/技术研究/"}]},{"title":"java片段","date":"2017-07-07T05:41:31.000Z","path":"2017/07/07/java片段/","text":"很热 字符串有整型的相互转换12String a = String.valueOf(2); //integer to numeric string int i = Integer.parseInt(a); //numeric string to an int 向文件末尾添加内容1234567891011BufferedWriter out = null; try &#123; out = new BufferedWriter(new FileWriter(”filename”, true)); out.write(”aString”); &#125; catch (IOException e) &#123; // error processing code &#125; finally &#123; if (out != null) &#123; out.close(); &#125; &#125; 得到当前方法的名字1String methodName = Thread.currentThread().getStackTrace()[1].getMethodName(); 转字符串到日期1java.util.Date = java.text.DateFormat.getDateInstance().parse(date String); 亦或是12SimpleDateFormat format = new SimpleDateFormat( \"dd.MM.yyyy\" ); Date date = format.parse( myString ); 使用JDBC链接Oracle1234567891011121314151617181920212223242526272829303132333435363738public class OracleJdbcTest &#123; String driverClass = \"oracle.jdbc.driver.OracleDriver\"; Connection con; public void init(FileInputStream fs) throws ClassNotFoundException, SQLException, FileNotFoundException, IOException &#123; Properties props = new Properties(); props.load(fs); String url = props.getProperty(\"db.url\"); String userName = props.getProperty(\"db.user\"); String password = props.getProperty(\"db.password\"); Class.forName(driverClass); con=DriverManager.getConnection(url, userName, password); &#125; public void fetch() throws SQLException, IOException &#123; PreparedStatement ps = con.prepareStatement(\"select SYSDATE from dual\"); ResultSet rs = ps.executeQuery(); while (rs.next()) &#123; // do the thing you do &#125; rs.close(); ps.close(); &#125; public static void main(String[] args) &#123; OracleJdbcTest test = new OracleJdbcTest(); test.init(); test.fetch(); &#125; &#125; 其他数据库同理 把 Java util.Date 转成 sql.Date12java.util.Date utilDate = new java.util.Date(); java.sql.Date sqlDate = new java.sql.Date(utilDate.getTime()); 使用NIO进行快速的文件拷贝public static void fileCopy( File in, File out ) throws IOException { FileChannel inChannel = new FileInputStream( in ).getChannel(); FileChannel outChannel = new FileOutputStream( out ).getChannel(); try { int maxCount = (64 * 1024 * 1024) - (32 * 1024); long size = inChannel.size(); long position = 0; while ( position &lt; size ) { position += inChannel.transferTo( position, maxCount, outChannel ); } } finally { if ( inChannel != null ) { inChannel.close(); } if ( outChannel != null ) { outChannel.close(); } } } 创建图片的缩略图1234567891011121314151617181920212223242526272829303132333435363738private void createThumbnail(String filename, int thumbWidth, int thumbHeight, int quality, String outFilename) throws InterruptedException, FileNotFoundException, IOException &#123; // load image from filename Image image = Toolkit.getDefaultToolkit().getImage(filename); MediaTracker mediaTracker = new MediaTracker(new Container()); mediaTracker.addImage(image, 0); mediaTracker.waitForID(0); // use this to test for errors at this point: System.out.println(mediaTracker.isErrorAny()); // determine thumbnail size from WIDTH and HEIGHT double thumbRatio = (double)thumbWidth / (double)thumbHeight; int imageWidth = image.getWidth(null); int imageHeight = image.getHeight(null); double imageRatio = (double)imageWidth / (double)imageHeight; if (thumbRatio &lt; imageRatio) &#123; thumbHeight = (int)(thumbWidth / imageRatio); &#125; else &#123; thumbWidth = (int)(thumbHeight * imageRatio); &#125; // draw original image to thumbnail image object and // scale it to the new size on-the-fly BufferedImage thumbImage = new BufferedImage(thumbWidth, thumbHeight, BufferedImage.TYPE_INT_RGB); Graphics2D graphics2D = thumbImage.createGraphics(); graphics2D.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR); graphics2D.drawImage(image, 0, 0, thumbWidth, thumbHeight, null); // save thumbnail image to outFilename BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(outFilename)); JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out); JPEGEncodeParam param = encoder.getDefaultJPEGEncodeParam(thumbImage); quality = Math.max(0, Math.min(quality, 100)); param.setQuality((float)quality / 100.0f, false); encoder.setJPEGEncodeParam(param); encoder.encode(thumbImage); out.close(); &#125; 创建 JSON 格式的数据123456789import org.json.JSONObject; ... ... JSONObject json = new JSONObject(); json.put(\"city\", \"Mumbai\"); json.put(\"country\", \"India\"); ... String output = json.toString(); ... 使用iText JAR生成PDF123456789101112131415161718192021222324252627282930import java.io.File; import java.io.FileOutputStream; import java.io.OutputStream; import java.util.Date; import com.lowagie.text.Document; import com.lowagie.text.Paragraph; import com.lowagie.text.pdf.PdfWriter; public class GeneratePDF &#123; public static void main(String[] args) &#123; try &#123; OutputStream file = new FileOutputStream(new File(\"C:\\\\Test.pdf\")); Document document = new Document(); PdfWriter.getInstance(document, file); document.open(); document.add(new Paragraph(\"Hello Kiran\")); document.add(new Paragraph(new Date().toString())); document.close(); file.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; HTTP 代理设置1234System.getProperties().put(\"http.proxyHost\", \"someProxyURL\"); System.getProperties().put(\"http.proxyPort\", \"someProxyPort\"); System.getProperties().put(\"http.proxyUser\", \"someUserName\"); System.getProperties().put(\"http.proxyPassword\", \"somePassword\"); 单实例Singleton 示例1234567891011121314public class SimpleSingleton &#123; private static SimpleSingleton singleInstance = new SimpleSingleton(); //Marking default constructor private //to avoid direct instantiation. private SimpleSingleton() &#123; &#125; //Get instance for class SimpleSingleton public static SimpleSingleton getInstance() &#123; return singleInstance; &#125; &#125; 亦或是12345678public enum SimpleSingleton &#123; INSTANCE; public void doSomething() &#123; &#125; &#125; //Call the method from Singleton: SimpleSingleton.INSTANCE.doSomething(); 抓屏程序1234567891011121314151617181920import java.awt.Dimension; import java.awt.Rectangle; import java.awt.Robot; import java.awt.Toolkit; import java.awt.image.BufferedImage; import javax.imageio.ImageIO; import java.io.File; ... public void captureScreen(String fileName) throws Exception &#123; Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize(); Rectangle screenRectangle = new Rectangle(screenSize); Robot robot = new Robot(); BufferedImage image = robot.createScreenCapture(screenRectangle); ImageIO.write(image, \"png\", new File(fileName)); &#125; ... 列出文件和目录123456789101112131415161718192021222324252627282930File dir = new File(\"directoryName\"); String[] children = dir.list(); if (children == null) &#123; //在windows系统中C盘下有隐藏不可读文件 // Either dir does not exist or is not a directory &#125; else &#123; for (int i=0; i &lt; children.length; i++) &#123; // Get filename of file or directory String filename = children[i]; &#125; &#125; // It is also possible to filter the list of returned files. // This example does not return any files that start with `.'. FilenameFilter filter = new FilenameFilter() &#123; public boolean accept(File dir, String name) &#123; return !name.startsWith(\".\"); &#125; &#125;; children = dir.list(filter); // The list of files can also be retrieved as File objects File[] files = dir.listFiles(); // This filter only returns directories FileFilter fileFilter = new FileFilter() &#123; public boolean accept(File file) &#123; return file.isDirectory(); &#125; &#125;; files = dir.listFiles(fileFilter); 创建ZIP和JAR文件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.util.zip.*; import java.io.*; public class ZipIt &#123; public static void main(String args[]) throws IOException &#123; if (args.length &lt; 2) &#123; System.err.println(\"usage: java ZipIt Zip.zip file1 file2 file3\"); System.exit(-1); &#125; File zipFile = new File(args[0]); if (zipFile.exists()) &#123; System.err.println(\"Zip file already exists, please try another\"); System.exit(-2); &#125; FileOutputStream fos = new FileOutputStream(zipFile); ZipOutputStream zos = new ZipOutputStream(fos); int bytesRead; byte[] buffer = new byte[1024]; CRC32 crc = new CRC32(); for (int i=1, n=args.length; i &lt; n; i++) &#123; String name = args[i]; File file = new File(name); if (!file.exists()) &#123; System.err.println(\"Skipping: \" + name); continue; &#125; BufferedInputStream bis = new BufferedInputStream( new FileInputStream(file)); crc.reset(); while ((bytesRead = bis.read(buffer)) != -1) &#123; crc.update(buffer, 0, bytesRead); &#125; bis.close(); // Reset to beginning of input stream bis = new BufferedInputStream( new FileInputStream(file)); ZipEntry entry = new ZipEntry(name); entry.setMethod(ZipEntry.STORED); entry.setCompressedSize(file.length()); entry.setSize(file.length()); entry.setCrc(crc.getValue()); zos.putNextEntry(entry); while ((bytesRead = bis.read(buffer)) != -1) &#123; zos.write(buffer, 0, bytesRead); &#125; bis.close(); &#125; zos.close(); &#125; &#125; 解析/读取XML 文件XML文件123456789101112131415161718&lt;?xml version=\"1.0\"?&gt; &lt;students&gt; &lt;student&gt; &lt;name&gt;John&lt;/name&gt; &lt;grade&gt;B&lt;/grade&gt; &lt;age&gt;12&lt;/age&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;Mary&lt;/name&gt; &lt;grade&gt;A&lt;/grade&gt; &lt;age&gt;11&lt;/age&gt; &lt;/student&gt; &lt;student&gt; &lt;name&gt;Simon&lt;/name&gt; &lt;grade&gt;A&lt;/grade&gt; &lt;age&gt;18&lt;/age&gt; &lt;/student&gt; &lt;/students&gt; java代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package net.viralpatel.java.xmlparser; import java.io.File; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList; public class XMLParser &#123; public void getAllUserNames(String fileName) &#123; try &#123; DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); File file = new File(fileName); if (file.exists()) &#123; Document doc = db.parse(file); Element docEle = doc.getDocumentElement(); // Print root element of the document System.out.println(\"Root element of the document: \" + docEle.getNodeName()); NodeList studentList = docEle.getElementsByTagName(\"student\"); // Print total student elements in document System.out .println(\"Total students: \" + studentList.getLength()); if (studentList != null &amp;&amp; studentList.getLength() &gt; 0) &#123; for (int i = 0; i &lt; studentList.getLength(); i++) &#123; Node node = studentList.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) &#123; System.out .println(\"=====================\"); Element e = (Element) node; NodeList nodeList = e.getElementsByTagName(\"name\"); System.out.println(\"Name: \" + nodeList.item(0).getChildNodes().item(0) .getNodeValue()); nodeList = e.getElementsByTagName(\"grade\"); System.out.println(\"Grade: \" + nodeList.item(0).getChildNodes().item(0) .getNodeValue()); nodeList = e.getElementsByTagName(\"age\"); System.out.println(\"Age: \" + nodeList.item(0).getChildNodes().item(0) .getNodeValue()); &#125; &#125; &#125; else &#123; System.exit(1); &#125; &#125; &#125; catch (Exception e) &#123; System.out.println(e); &#125; &#125; public static void main(String[] args) &#123; XMLParser parser = new XMLParser(); parser.getAllUserNames(\"c:\\\\test.xml\"); &#125; &#125; 把 Array 转换成 Map123456789101112131415import java.util.Map; import org.apache.commons.lang.ArrayUtils; public class Main &#123; public static void main(String[] args) &#123; String[][] countries = &#123; &#123; \"United States\", \"New York\" &#125;, &#123; \"United Kingdom\", \"London\" &#125;, &#123; \"Netherland\", \"Amsterdam\" &#125;, &#123; \"Japan\", \"Tokyo\" &#125;, &#123; \"France\", \"Paris\" &#125; &#125;; Map countryCapitals = ArrayUtils.toMap(countries); System.out.println(\"Capital of Japan is \" + countryCapitals.get(\"Japan\")); System.out.println(\"Capital of France is \" + countryCapitals.get(\"France\")); &#125; &#125; 发送邮件1234567891011121314151617181920212223242526272829303132333435363738import javax.mail.*; import javax.mail.internet.*; import java.util.*; public void postMail( String recipients[ ], String subject, String message , String from) throws MessagingException &#123; boolean debug = false; //Set the host smtp address Properties props = new Properties(); props.put(\"mail.smtp.host\", \"smtp.example.com\"); // create some properties and get the default Session Session session = Session.getDefaultInstance(props, null); session.setDebug(debug); // create a message Message msg = new MimeMessage(session); // set the from and to address InternetAddress addressFrom = new InternetAddress(from); msg.setFrom(addressFrom); InternetAddress[] addressTo = new InternetAddress[recipients.length]; for (int i = 0; i &lt; recipients.length; i++) &#123; addressTo[i] = new InternetAddress(recipients[i]); &#125; msg.setRecipients(Message.RecipientType.TO, addressTo); // Optional : You can also set your custom headers in the Email if you Want msg.addHeader(\"MyHeaderName\", \"myHeaderValue\"); // Setting the Subject and Content Type msg.setSubject(subject); msg.setContent(message, \"text/plain\"); Transport.send(msg); &#125; 发送代数据的HTTP 请求123456789101112131415161718import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.URL; public class Main &#123; public static void main(String[] args) &#123; try &#123; URL my_url = new URL(\"http://coolshell.cn/\"); BufferedReader br = new BufferedReader(new InputStreamReader(my_url.openStream())); String strTemp = \"\"; while(null != (strTemp = br.readLine()))&#123; System.out.println(strTemp); &#125; &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; &#125; 改变数组的大小123456789101112131415161718192021222324252627/** * Reallocates an array with a new size, and copies the contents * of the old array to the new array. * @param oldArray the old array, to be reallocated. * @param newSize the new array size. * @return A new array with the same contents. */ private static Object resizeArray (Object oldArray, int newSize) &#123; int oldSize = java.lang.reflect.Array.getLength(oldArray); Class elementType = oldArray.getClass().getComponentType(); Object newArray = java.lang.reflect.Array.newInstance( elementType,newSize); int preserveLength = Math.min(oldSize,newSize); if (preserveLength &gt; 0) System.arraycopy (oldArray,0,newArray,0,preserveLength); return newArray; &#125; // Test routine for resizeArray(). public static void main (String[] args) &#123; int[] a = &#123;1,2,3&#125;; a = (int[])resizeArray(a,5); a[3] = 4; a[4] = 5; for (int i=0; i&lt;a.length; i++) System.out.println (a[i]); &#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://aschouas.com/categories/JAVA/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://aschouas.com/tags/笔记/"}]},{"title":"Java并发之synchronized实现原理","date":"2017-06-06T02:43:52.000Z","path":"2017/06/06/Java并发之synchronized实现原理/","text":"难受 转自http://blog.csdn.net/javazejian/article/details/72828483#comments?ref=myread 线程安全是并发编程中的重要关注点，应该注意到的是，造成线程安全问题的主要诱因有两点，一是存在共享数据(也称临界资源)，二是存在多条线程共同操作共享数据。因此为了解决这个问题，我们可能需要这样一个方案，当存在多个线程操作共享数据时，需要保证同一时刻有且只有一个线程在操作共享数据，其他线程必须等到该线程处理完数据后再进行，这种方式有个高尚的名称叫互斥锁，即能达到互斥访问目的的锁，也就是说当一个共享数据被当前正在访问的线程加上互斥锁后，在同一个时刻，其他线程只能处于等待的状态，直到当前线程处理完毕释放该锁。在 Java 中，关键字 synchronized可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块(主要是对方法或者代码块中存在共享数据的操作)，同时我们还应该注意到synchronized另外一个重要的作用，synchronized可保证一个线程的变化(主要是共享数据的变化)被其他线程所看到（保证可见性，完全可以替代Volatile功能），这点确实也是很重要的。 synchronized的三种应用方式synchronized关键字最主要有以下3种应用方式，下面分别介绍 修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁 修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁 修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。 synchronized作用于实例方法所谓的实例对象锁就是用synchronized修饰实例对象中的实例方法，注意是实例方法不包括静态方法，如下 12345678910111213141516171819202122232425262728293031public class AccountingSync implements Runnable&#123; //共享资源(临界资源) static int i=0; /** * synchronized 修饰实例方法 */ public synchronized void increase()&#123; i++; &#125; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; increase(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; AccountingSync instance=new AccountingSync(); Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(i); &#125; /** * 输出结果: * 2000000 */&#125; 上述代码中，我们开启两个线程操作同一个共享资源即变量i，由于i++;操作并不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分两步完成，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全。此时我们应该注意到synchronized修饰的是实例方法increase，在这样的情况下，当前线程的锁便是实例对象instance，注意Java中的线程同步锁可以是任意对象。从代码执行结果来看确实是正确的，倘若我们没有使用synchronized关键字，其最终输出结果就很可能小于2000000，这便是synchronized关键字的作用。这里我们还需要意识到，当一个线程正在访问一个对象的 synchronized 实例方法，那么其他线程不能访问该对象的其他 synchronized 方法，毕竟一个对象只有一把锁，当一个线程获取了该对象的锁之后，其他线程无法获取该对象的锁，所以无法访问该对象的其他synchronized实例方法，但是其他线程还是可以访问该实例对象的其他非synchronized方法，当然如果是一个线程 A 需要访问实例对象 obj1 的 synchronized 方法 f1(当前对象锁是obj1)，另一个线程 B 需要访问实例对象 obj2 的 synchronized 方法 f2(当前对象锁是obj1)，这样是允许的，因为两个实例对象锁并不同相同，此时如果两个线程操作数据并非共享的，线程安全是有保障的，遗憾的是如果两个线程操作的是共享数据，那么线程安全就有可能无法保证了，如下代码将演示出该现象 123456789101112131415161718192021222324public class AccountingSyncBad implements Runnable&#123; static int i=0; public synchronized void increase()&#123; i++; &#125; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; increase(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //new新实例 Thread t1=new Thread(new AccountingSyncBad()); //new新实例 Thread t2=new Thread(new AccountingSyncBad()); t1.start(); t2.start(); //join含义:当前线程A等待thread线程终止之后才能从thread.join()返回 t1.join(); t2.join(); System.out.println(i); &#125;&#125; 上述代码与前面不同的是我们同时创建了两个新实例AccountingSyncBad，然后启动两个不同的线程对共享变量i进行操作，但很遗憾操作结果是1452317而不是期望结果2000000，因为上述代码犯了严重的错误，虽然我们使用synchronized修饰了increase方法，但却new了两个不同的实例对象，这也就意味着存在着两个不同的实例对象锁，因此t1和t2都会进入各自的对象锁，也就是说t1和t2线程使用的是不同的锁，因此线程安全是无法保证的。解决这种困境的的方式是将synchronized作用于静态的increase方法，这样的话，对象锁就当前类对象，由于无论创建多少个实例对象，但对于的类对象拥有只有一个，所有在这样的情况下对象锁就是唯一的。下面我们看看如何使用将synchronized作用于静态的increase方法。 synchronized作用于静态方法当synchronized作用于静态方法时，其锁就是当前类的class对象锁。由于静态成员不专属于任何一个实例对象，是类成员，因此通过class对象锁可以控制静态 成员的并发操作。需要注意的是如果一个线程A调用一个实例对象的非static synchronized方法，而线程B需要调用这个实例对象所属类的静态 synchronized方法，是允许的，不会发生互斥现象，因为访问静态 synchronized 方法占用的锁是当前类的class对象，而访问非静态 synchronized 方法占用的锁是当前实例对象锁，看如下代码 123456789101112131415161718192021222324252627282930313233343536public class AccountingSyncClass implements Runnable&#123; static int i=0; /** * 作用于静态方法,锁是当前class对象,也就是 * AccountingSyncClass类对应的class对象 */ public static synchronized void increase()&#123; i++; &#125; /** * 非静态,访问时锁不一样不会发生互斥 */ public synchronized void increase4Obj()&#123; i++; &#125; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; increase(); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //new新实例 Thread t1=new Thread(new AccountingSyncClass()); //new心事了 Thread t2=new Thread(new AccountingSyncClass()); //启动线程 t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); &#125;&#125; 由于synchronized关键字修饰的是静态increase方法，与修饰实例方法不同的是，其锁对象是当前类的class对象。注意代码中的increase4Obj方法是实例方法，其对象锁是当前实例对象，如果别的线程调用该方法，将不会产生互斥现象，毕竟锁对象不同，但我们应该意识到这种情况下可能会发现线程安全问题(操作了共享静态变量i)。 synchronized同步代码块除了使用关键字修饰实例方法和静态方法外，还可以使用同步代码块，在某些情况下，我们编写的方法体可能比较大，同时存在一些比较耗时的操作，而需要同步的代码又只有一小部分，如果直接对整个方法进行同步操作，可能会得不偿失，此时我们可以使用同步代码块的方式对需要同步的代码进行包裹，这样就无需对整个方法进行同步操作了，同步代码块的使用示例如下： 123456789101112131415161718192021public class AccountingSync implements Runnable&#123; static AccountingSync instance=new AccountingSync(); static int i=0; @Override public void run() &#123; //省略其他耗时操作.... //使用同步代码块对变量i进行同步操作,锁对象为instance synchronized(instance)&#123; for(int j=0;j&lt;1000000;j++)&#123; i++; &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); &#125;&#125; 从代码看出，将synchronized作用于一个给定的实例对象instance，即当前实例对象就是锁对象，每次当线程进入synchronized包裹的代码块时就会要求当前线程持有instance实例对象锁，如果当前有其他线程正持有该对象锁，那么新到的线程就必须等待，这样也就保证了每次只有一个线程执行i++;操作。当然除了instance作为对象外，我们还可以使用this对象(代表当前实例)或者当前类的class对象作为锁，如下代码： 12345678910111213//this,当前实例对象锁synchronized(this)&#123; for(int j=0;j&lt;1000000;j++)&#123; i++; &#125;&#125;//class对象锁synchronized(AccountingSync.class)&#123; for(int j=0;j&lt;1000000;j++)&#123; i++; &#125;&#125; 了解完synchronized的基本含义及其使用方式后，下面我们将进一步深入理解synchronized的底层实现原理。 synchronized底层语义原理Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现， 无论是显式同步(有明确的 monitorenter 和 monitorexit 指令,即同步代码块)还是隐式同步都是如此。在 Java 语言中，同步用的最多的地方可能是被 synchronized 修饰的同步方法。同步方法 并不是由 monitorenter 和 monitorexit 指令来实现同步的，而是由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的，关于这点，稍后详细分析。下面先来了解一个概念Java对象头，这对深入理解synchronized实现原理非常关键。 理解Java对象头与Monitor在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。如下： 实例变量：存放类的属性数据信息，包括父类的属性信息，如果是数组的实例部分还包括数组的长度，这部分内存按4字节对齐。 填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐，这点了解即可。 而对于顶部，则是Java头对象，它实现synchronized的锁对象的基础，这点我们重点分析它，一般而言，synchronized使用的锁对象是存储在Java对象头里的，jvm中采用2个字来存储对象头(如果对象是数组则会分配3个字，多出来的1个字记录的是数组长度)，其主要结构是由Mark Word 和 Class Metadata Address 组成，其结构说明如下表： 虚拟机位数 头对象结构 说明 32/64bit Mark Word 存储对象的hashCode、锁信息或分代年龄或GC标志等信息 32/64bit Class Metadata Address 类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。 其中Mark Word在默认情况下存储着对象的HashCode、分代年龄、锁标记位等以下是32位JVM的Mark Word默认存储结构 锁状态 25bit 4bit 1bit是否是偏向锁 2bit 锁标志位 无锁状态 对象HashCode 对象分代年龄 0 01 由于对象头的信息是与对象自身定义的数据没有关系的额外存储成本，因此考虑到JVM的空间效率，Mark Word 被设计成为一个非固定的数据结构，以便存储更多有效的数据，它会根据对象本身的状态复用自己的存储空间，如32位JVM下，除了上述列出的Mark Word默认存储结构外，还有如下可能变化的结构： 其中轻量级锁和偏向锁是Java 6 对 synchronized 锁进行优化后新增加的，稍后我们会简要分析。这里我们主要分析一下重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的） 123456789101112131415161718ObjectMonitor() &#123; _header = NULL; _count = 0; //记录个数 _waiters = 0, _recursions = 0; _object = NULL; _owner = NULL; _WaitSet = NULL; //处于wait状态的线程，会被加入到_WaitSet _WaitSetLock = 0 ; _Responsible = NULL ; _succ = NULL ; _cxq = NULL ; FreeNext = NULL ; _EntryList = NULL ; //处于等待锁block状态的线程，会被加入到该列表 _SpinFreq = 0 ; _SpinClock = 0 ; OwnerIsThread = 0 ; &#125; ObjectMonitor中有两个队列，_WaitSet 和 _EntryList，用来保存ObjectWaiter对象列表( 每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用 wait() 方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入 WaitSe t集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示 由此看来，monitor对象存在于每个Java对象的对象头中(存储的指针的指向)，synchronized锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因，同时也是notify/notifyAll/wait等方法存在于顶级对象Object中的原因(关于这点稍后还会进行分析)，ok~，有了上述知识基础后，下面我们将进一步分析synchronized在字节码层面的具体语义实现。 synchronized代码块底层原理现在我们重新定义一个synchronized修饰的同步代码块，在代码块中操作共享变量i，如下 1234567891011public class SyncCodeBlock &#123; public int i; public void syncTask()&#123; //同步代码库 synchronized (this)&#123; i++; &#125; &#125;&#125; 编译上述代码并使用javap反编译后得到字节码如下(这里我们省略一部分没有必要的信息)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950Classfile /Users/zejian/Downloads/Java8_Action/src/main/java/com/zejian/concurrencys/SyncCodeBlock.class Last modified 2017-6-2; size 426 bytes MD5 checksum c80bc322c87b312de760942820b4fed5 Compiled from \"SyncCodeBlock.java\"public class com.zejian.concurrencys.SyncCodeBlock minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: //........省略常量池中数据 //构造函数 public com.zejian.concurrencys.SyncCodeBlock(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 7: 0 //===========主要看看syncTask方法实现================ public void syncTask(); descriptor: ()V flags: ACC_PUBLIC Code: stack=3, locals=3, args_size=1 0: aload_0 1: dup 2: astore_1 3: monitorenter //注意此处，进入同步方法 4: aload_0 5: dup 6: getfield #2 // Field i:I 9: iconst_1 10: iadd 11: putfield #2 // Field i:I 14: aload_1 15: monitorexit //注意此处，退出同步方法 16: goto 24 19: astore_2 20: aload_1 21: monitorexit //注意此处，退出同步方法 22: aload_2 23: athrow 24: return Exception table: //省略其他字节码.......&#125;SourceFile: \"SyncCodeBlock.java\" 我们主要关注字节码中的如下代码 1234563: monitorenter //进入同步方法//..........省略其他 15: monitorexit //退出同步方法16: goto 24//省略其他.......21: monitorexit //退出同步方法 从字节码中可知同步语句块的实现使用的是monitorenter 和 monitorexit 指令，其中monitorenter指令指向同步代码块的开始位置，monitorexit指令则指明同步代码块的结束位置，当执行monitorenter指令时，当前线程将试图获取 objectref(即对象锁) 所对应的 monitor 的持有权，当 objectref 的 monitor 的进入计数器为 0，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有 objectref 的 monitor 的持有权，那它可以重入这个 monitor (关于重入性稍后会分析)，重入时计数器的值也会加 1。倘若其他线程已经拥有 objectref 的 monitor 的所有权，那当前线程将被阻塞，直到正在执行线程执行完毕，即monitorexit指令被执行，执行线程将释放 monitor(锁)并设置计数器值为0 ，其他线程将有机会持有 monitor 。值得注意的是编译器将会确保无论方法通过何种方式完成，方法中调用过的每条 monitorenter 指令都有执行其对应 monitorexit 指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时 monitorenter 和 monitorexit 指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行 monitorexit 指令。从字节码中也可以看出多了一个monitorexit指令，它就是异常结束时被执行的释放monitor 的指令。 synchronized方法底层原理方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。如果一个同步方法执行期间抛 出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的monitor将在异常抛到同步方法之外时自动释放。下面我们看看字节码层面如何实现： 12345678public class SyncMethod &#123; public int i; public synchronized void syncTask()&#123; i++; &#125;&#125; 使用javap反编译后的字节码如下： 123456789101112131415161718192021222324252627282930Classfile /Users/zejian/Downloads/Java8_Action/src/main/java/com/zejian/concurrencys/SyncMethod.class Last modified 2017-6-2; size 308 bytes MD5 checksum f34075a8c059ea65e4cc2fa610e0cd94 Compiled from \"SyncMethod.java\"public class com.zejian.concurrencys.SyncMethod minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool; //省略没必要的字节码 //==================syncTask方法====================== public synchronized void syncTask(); descriptor: ()V //方法标识ACC_PUBLIC代表public修饰，ACC_SYNCHRONIZED指明该方法为同步方法 flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=3, locals=1, args_size=1 0: aload_0 1: dup 2: getfield #2 // Field i:I 5: iconst_1 6: iadd 7: putfield #2 // Field i:I 10: return LineNumberTable: line 12: 0 line 13: 10&#125;SourceFile: \"SyncMethod.java\" 从字节码中可以看出，synchronized修饰的方法并没有monitorenter指令和monitorexit指令，取得代之的确实是ACC_SYNCHRONIZED标识，该标识指明了该方法是一个同步方法，JVM通过该ACC_SYNCHRONIZED访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。这便是synchronized锁在同步代码块和同步方法上实现的基本原理。同时我们还必须注意到的是在Java早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的Mutex Lock来实现的，而操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，这也是为什么早期的synchronized效率低的原因。庆幸的是在Java 6之后Java官方对从JVM层面对synchronized较大优化，所以现在的synchronized锁效率也优化得很不错了，Java 6之后，为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁，接下来我们将简单了解一下Java官方在JVM层面对synchronized锁的优化。 Java虚拟机对synchronized的优化锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级，关于重量级锁，前面我们已详细分析过，下面我们将介绍偏向锁和轻量级锁以及JVM的其他优化手段，这里并不打算深入到每个锁的实现和转换过程更多地是阐述Java虚拟机所提供的每个锁的核心优化思想，毕竟涉及到具体过程比较繁琐，如需了解详细过程可以查阅《深入理解Java虚拟机原理》。 偏向锁偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。 轻量级锁倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场合，就会导致轻量级锁膨胀为重量级锁。 自旋锁轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。 锁消除消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间，如下StringBuffer的append是一个同步方法，但是在add方法中的StringBuffer属于一个局部变量，并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。 12345678910111213141516171819202122/** * Created by zejian on 2017/6/4. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] * 消除StringBuffer同步锁 */public class StringBufferRemoveSync &#123; public void add(String str1, String str2) &#123; //StringBuffer是线程安全,由于sb只会在append方法中使用,不可能被其他线程引用 //因此sb属于不可能共享的资源,JVM会自动消除内部的锁 StringBuffer sb = new StringBuffer(); sb.append(str1).append(str2); &#125; public static void main(String[] args) &#123; StringBufferRemoveSync rmsync = new StringBufferRemoveSync(); for (int i = 0; i &lt; 10000000; i++) &#123; rmsync.add(\"abc\", \"123\"); &#125; &#125;&#125; 关于synchronized 可能需要了解的关键点synchronized的可重入性从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。如下： 1234567891011121314151617181920212223242526272829public class AccountingSync implements Runnable&#123; static AccountingSync instance=new AccountingSync(); static int i=0; static int j=0; @Override public void run() &#123; for(int j=0;j&lt;1000000;j++)&#123; //this,当前实例对象锁 synchronized(this)&#123; i++; increase();//synchronized的可重入性 &#125; &#125; &#125; public synchronized void increase()&#123; j++; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread t1=new Thread(instance); Thread t2=new Thread(instance); t1.start();t2.start(); t1.join();t2.join(); System.out.println(i); &#125;&#125; 正如代码所演示的，在获取当前实例对象锁后进入synchronized代码块执行同步代码，并在代码块中调用了当前实例对象的另外一个synchronized方法，再次请求当前实例锁时，将被允许，进而执行方法体代码，这就是重入锁最直接的体现，需要特别注意另外一种情况，当子类继承父类时，子类也是可以通过可重入锁调用父类的同步方法。注意由于synchronized是基于monitor实现的，因此每次重入，monitor中的计数器仍会加1。 线程中断与synchronized线程中断正如中断二字所表达的意义，在线程运行(run方法)中间打断它，在Java中，提供了以下3个有关线程中断的方法 12345678//中断线程（实例方法）public void Thread.interrupt();//判断线程是否被中断（实例方法）public boolean Thread.isInterrupted();//判断是否被中断并清除当前中断状态（静态方法）public static boolean Thread.interrupted(); 当一个线程处于被阻塞状态或者试图执行一个阻塞操作时，使用Thread.interrupt()方式中断该线程，注意此时将会抛出一个InterruptedException的异常，同时中断状态将会被复位(由中断状态改为非中断状态)，如下代码将演示该过程： 12345678910111213141516171819202122232425262728293031public class InterruputSleepThread3 &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1 = new Thread() &#123; @Override public void run() &#123; //while在try中，通过异常中断就可以退出run循环 try &#123; while (true) &#123; //当前线程处于阻塞状态，异常必须捕捉处理，无法往外抛出 TimeUnit.SECONDS.sleep(2); &#125; &#125; catch (InterruptedException e) &#123; System.out.println(\"Interruted When Sleep\"); boolean interrupt = this.isInterrupted(); //中断状态被复位 System.out.println(\"interrupt:\"+interrupt); &#125; &#125; &#125;; t1.start(); TimeUnit.SECONDS.sleep(2); //中断处于阻塞状态的线程 t1.interrupt(); /** * 输出结果: Interruted When Sleep interrupt:false */ &#125;&#125; 如上述代码所示，我们创建一个线程，并在线程中调用了sleep方法从而使用线程进入阻塞状态，启动线程后，调用线程实例对象的interrupt方法中断阻塞异常，并抛出InterruptedException异常，此时中断状态也将被复位。这里有些人可能会诧异，为什么不用Thread.sleep(2000);而是用TimeUnit.SECONDS.sleep(2);其实原因很简单，前者使用时并没有明确的单位说明，而后者非常明确表达秒的单位，事实上后者的内部实现最终还是调用了Thread.sleep(2000);，但为了编写的代码语义更清晰，建议使用TimeUnit.SECONDS.sleep(2);的方式，注意TimeUnit是个枚举类型。ok~，除了阻塞中断的情景，我们还可能会遇到处于运行期且非阻塞的状态的线程，这种情况下，直接调用Thread.interrupt()中断线程是不会得到任响应的，如下代码，将无法中断非阻塞状态下的线程： 1234567891011121314151617181920212223public class InterruputThread &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1=new Thread()&#123; @Override public void run()&#123; while(true)&#123; System.out.println(\"未被中断\"); &#125; &#125; &#125;; t1.start(); TimeUnit.SECONDS.sleep(2); t1.interrupt(); /** * 输出结果(无限执行): 未被中断 未被中断 未被中断 ...... */ &#125;&#125; 虽然我们调用了interrupt方法，但线程t1并未被中断，因为处于非阻塞状态的线程需要我们手动进行中断检测并结束程序，改进后代码如下： 123456789101112131415161718192021222324252627public class InterruputThread &#123; public static void main(String[] args) throws InterruptedException &#123; Thread t1=new Thread()&#123; @Override public void run()&#123; while(true)&#123; //判断当前线程是否被中断 if (this.isInterrupted())&#123; System.out.println(\"线程中断\"); break; &#125; &#125; System.out.println(\"已跳出循环,线程中断!\"); &#125; &#125;; t1.start(); TimeUnit.SECONDS.sleep(2); t1.interrupt(); /** * 输出结果: 线程中断 已跳出循环,线程中断! */ &#125;&#125; 是的，我们在代码中使用了实例方法isInterrupted判断线程是否已被中断，如果被中断将跳出循环以此结束线程。综合所述，可以简单总结一下中断两种情况，一种是当线程处于阻塞状态或者试图执行一个阻塞操作时，我们可以使用实例方法interrupt()进行线程中断，执行中断操作后将会抛出interruptException异常(该异常必须捕捉无法向外抛出)并将中断状态复位，另外一种是当线程处于运行状态时，我们也可调用实例方法interrupt()进行线程中断，但同时必须手动判断中断状态，并编写中断线程的代码(其实就是结束run方法体的代码)。有时我们在编码时可能需要兼顾以上两种情况，那么就可以如下编写： 12345678910public void run()&#123; try &#123; //判断当前线程是否已中断,注意interrupted方法是静态的,执行后会对中断状态进行复位 while (!Thread.interrupted()) &#123; TimeUnit.SECONDS.sleep(2); &#125; &#125; catch (InterruptedException e) &#123; &#125;&#125; 中断与synchronized事实上线程的中断操作对于正在等待获取的锁对象的synchronized方法或者代码块并不起作用，也就是对于synchronized来说，如果一个线程在等待锁，那么结果只有两种，要么它获得这把锁继续执行，要么它就保存等待，即使调用中断线程的方法，也不会生效。演示代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Created by zejian on 2017/6/2. * Blog : http://blog.csdn.net/javazejian [原文地址,请尊重原创] */public class SynchronizedBlocked implements Runnable&#123; public synchronized void f() &#123; System.out.println(\"Trying to call f()\"); while(true) // Never releases lock Thread.yield(); &#125; /** * 在构造器中创建新线程并启动获取对象锁 */ public SynchronizedBlocked() &#123; //该线程已持有当前实例锁 new Thread() &#123; public void run() &#123; f(); // Lock acquired by this thread &#125; &#125;.start(); &#125; public void run() &#123; //中断判断 while (true) &#123; if (Thread.interrupted()) &#123; System.out.println(\"中断线程!!\"); break; &#125; else &#123; f(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; SynchronizedBlocked sync = new SynchronizedBlocked(); Thread t = new Thread(sync); //启动后调用f()方法,无法获取当前实例锁处于等待状态 t.start(); TimeUnit.SECONDS.sleep(1); //中断线程,无法生效 t.interrupt(); &#125;&#125; 我们在SynchronizedBlocked构造函数中创建一个新线程并启动获取调用f()获取到当前实例锁，由于SynchronizedBlocked自身也是线程，启动后在其run方法中也调用了f()，但由于对象锁被其他线程占用，导致t线程只能等到锁，此时我们调用了t.interrupt();但并不能中断线程。 等待唤醒机制与synchronized所谓等待唤醒机制本篇主要指的是notify/notifyAll和wait方法，在使用这3个方法时，必须处于synchronized代码块或者synchronized方法中，否则就会抛出IllegalMonitorStateException异常，这是因为调用这几个方法前必须拿到当前对象的监视器monitor对象，也就是说notify/notifyAll和wait方法依赖于monitor对象，在前面的分析中，我们知道monitor 存在于对象头的Mark Word 中(存储monitor引用指针)，而synchronized关键字可以获取 monitor ，这也就是为什么notify/notifyAll和wait方法必须在synchronized代码块或者synchronized方法调用的原因。 12345synchronized (obj) &#123; obj.wait(); obj.notify(); obj.notifyAll(); &#125; 需要特别理解的一点是，与sleep方法不同的是wait方法调用完成后，线程将被暂停，但wait方法将会释放当前持有的监视器锁(monitor)，直到有线程调用notify/notifyAll方法后方能继续执行，而sleep方法只让线程休眠并不释放锁。同时notify/notifyAll方法调用后，并不会马上释放监视器锁，而是在相应的synchronized(){}/synchronized方法执行结束后才自动释放锁。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://aschouas.com/categories/JAVA/"}],"tags":[{"name":"技术研究","slug":"技术研究","permalink":"http://aschouas.com/tags/技术研究/"}]},{"title":"懵逼的java","date":"2017-05-26T07:39:03.000Z","path":"2017/05/26/懵逼的java/","text":"周六要上班 今天在论坛看到一个很有意思的问题，自认为对java略有心得，但是按照以往的思维，做错了！ 题目是这样的123456789101112131415161718192021222324252627public static void main(String[] args) &#123; //输出顺序和a，b的值 staticFunction();&#125;static Stscan st = new Stscan();static &#123; System.out.println(\"1\");&#125;&#123; System.out.println(\"2\");&#125;Stscan() &#123; System.out.println(\"3\"); System.out.println(\"a=\" + a + \" b=\" + b);&#125;public static void staticFunction() &#123; System.out.println(\"4\");&#125;int a = 110;static int b = 112; 输出的顺序和 a,b的值： 开始按照java的赋值顺序： 1.父类的静态变量赋值 2.自身的静态变量赋值 3.父类成员变量赋值 4.父类块赋值 5.父类构造器赋值 6.自身成员变量赋值 7.自身块赋值 8.自身构造器赋值 但是还是不对，这就比较尴尬了。 但是后来发现：可以从类的生命周期和对象的初始化来分析：1.类的生命周期是：加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载，只有在准备阶段和初始化阶段才会涉及类变量的初始化和赋值，因此只针对这两个阶段进行分析；2.类的准备阶段需要做是为类变量分配内存并设置默认值，因此类变量st为null、b为0；（需要注意的是如果类变量是final在加载阶段就已经完成了初始化，可以把b设置为final试试）；3.类的初始化阶段需要做是执行类构造器（类构造器是编译器收集所有静态语句块和类变量的赋值语句按语句在源码中的顺序合并生成类构造器，对象的构造方法是init，类的构造方法是cinit，可以在堆栈信息中看到），因此先执行第一条静态变量的赋值语句即st = new StaticTest ()，此时会进行对象的初始化，对象的初始化是先初始化成员变量再执行构造方法，因此打印2-&gt;设置a为110-&gt;执行构造方法(打印3,此时a已经赋值为110，但是b只是设置了默认值0，并未完成赋值动作)，等对象的初始化完成后继续执行之前的类构造器的语句，接下来就不详细说了，按照语句在源码中的顺序执行即可； 我们来看一个简化的代码: 12345678910public class Test &#123; public static void main(String[] args) &#123; func(); &#125; static Test st = new Test(); static void func()&#123;&#125; &#125; 1、首先在执行此段代码时，首先由main方法的调用触发静态初始化。 2、在初始化Test 类的静态部分时，遇到st这个成员。 3、但凑巧这个变量引用的是本类的实例。 4、那么问题来了，此时静态初始化过程还没完成就要初始化实例部分了。是这样么？ 5、从人的角度是的。但从java的角度，一旦开始初始化静态部分，无论是否完成，后续都不会再重新触发静态初始化流程了。 6、因此在实例化st变量时，实际上是把实例初始化嵌入到了静态初始化流程中，并且在楼主的问题中，嵌入到了静态初始化的起始位置。 这就导致了实例初始化完全至于静态初始化之前。这也是导致a有值b没值的原因。 7、最后再考虑到文本顺序，结果就显而易见了。 路漫漫","categories":[{"name":"教程","slug":"教程","permalink":"http://aschouas.com/categories/教程/"}],"tags":[{"name":"技术研究","slug":"技术研究","permalink":"http://aschouas.com/tags/技术研究/"}]},{"title":"java8新特性","date":"2017-05-24T02:35:19.000Z","path":"2017/05/24/java8新特性/","text":"晚上吃水煮鱼 虽然java8出了很久了，自己也有在用，但是没有整理过，借此整理一下. 接口的默认方法Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法 123456interface Formula &#123; double calculate(int a); default double sqrt(int a) &#123; return Math.sqrt(a); &#125;&#125; Formula接口在拥有calculate方法之外同时还定义了sqrt方法，实现了Formula接口的子类只需要实现一个calculate方法，默认方法sqrt将在子类上可以直接使用。 12345678Formula formula = new Formula() &#123;//实现匿名类 @Override public double calculate(int a) &#123; return sqrt(a * 100); &#125;&#125;;formula.calculate(100); // 100.0formula.sqrt(16); // 4.0 Lambda 表达式先看老版本排列字符串 1234567List&lt;String&gt; names = Arrays.asList(\"c\", \"b\", \"d\", \"r\");Collections.sort(names, new Comparator&lt;String&gt;() &#123; @Override public int compare(String a, String b) &#123; return b.compareTo(a); &#125;&#125;); 给静态方法 Collections.sort 传入一个List对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给sort方法。 java8就不需要使用匿名对象的方式，lambda: 123Collections.sort(names, (String a, String b) -&gt; &#123; return b.compareTo(a);&#125;); 函数式接口将lambda表达式映射到一个单方法的接口上 1234567@FunctionalInterfaceinterface Converter&lt;F, T&gt; &#123; T convert(F from);&#125;Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);Integer converted = converter.convert(\"123\");System.out.println(converted); // 123 方法与构造函数引用静态方法引用 123Converter&lt;String, Integer&gt; converter = Integer::valueOf;Integer converted = converter.convert(\"123\");System.out.println(converted); // 123 Java 8 允许你使用 :: 关键字来传递方法或者构造函数引用，上面的代码展示了如何引用一个静态方法，我们也可以引用一个对象的方法： 123converter = something::startsWith;String converted = converter.convert(\"Java\");System.out.println(converted); // \"J\" 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类： 123456789class Person &#123; String firstName; String lastName; Person() &#123;&#125; Person(String firstName, String lastName) &#123; this.firstName = firstName; this.lastName = lastName; &#125;&#125; 接下来我们指定一个用来创建Person对象的对象工厂接口： 123interface PersonFactory&lt;P extends Person&gt; &#123; P create(String firstName, String lastName);&#125; 这里我们使用构造函数引用来将他们关联起来，而不是实现一个完整的工厂： 12PersonFactory&lt;Person&gt; personFactory = Person::new;Person person = personFactory.create(\"Peter\", \"Parker\"); 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的签名来选择合适的构造函数。 Lambda 作用域在lambda表达式中访问外层作用域和老版本的匿名对象中的方式很相似。你可以直接访问标记了final的外层局部变量，或者实例的字段以及静态变量。ambda内部对于实例的字段以及静态变量是即可读又可写. Streams 详解 (感谢www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/)Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。 流的使用详解简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。 流的构造与转换123456789// 1. Individual valuesStream stream = Stream.of(\"a\", \"b\", \"c\");// 2. ArraysString [] strArray = new String[] &#123;\"a\", \"b\", \"c\"&#125;;stream = Stream.of(strArray);stream = Arrays.stream(strArray);// 3. CollectionsList&lt;String&gt; list = Arrays.asList(strArray);stream = list.stream(); 需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream： IntStream、LongStream、DoubleStream。当然我们也可以用 Stream、Stream &gt;、Stream，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。 数值流的构造 123IntStream.of(new int[]&#123;1, 2, 3&#125;).forEach(System.out::println);IntStream.range(1, 3).forEach(System.out::println);IntStream.rangeClosed(1, 3).forEach(System.out::println); 流转换为其它数据结构123456789// 1. ArrayString[] strArray1 = stream.toArray(String[]::new);// 2. CollectionList&lt;String&gt; list1 = stream.collect(Collectors.toList());List&lt;String&gt; list2 = stream.collect(Collectors.toCollection(ArrayList::new));Set set1 = stream.collect(Collectors.toSet());Stack stack1 = stream.collect(Collectors.toCollection(Stack::new));// 3. StringString str = stream.collect(Collectors.joining()).toString(); 一个 Stream 只可以使用一次，上面的代码为了简洁而重复使用了数次。 流的操作接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。 Intermediate:map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered Terminal:forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator Short-circuiting:anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit map/flatMap 转换大写 1234//把所有的单词转换为大写。List&lt;String&gt; output = wordList.stream().map(String::toUpperCase).collect(Collectors.toList()); 平方数 1234List&lt;Integer&gt; nums = Arrays.asList(1, 2, 3, 4);List&lt;Integer&gt; squareNums = nums.stream().map(n -&gt; n * n).collect(Collectors.toList());//&#123;1, 4, 9, 16&#125; 一对多 1234567Stream&lt;List&lt;Integer&gt;&gt; inputStream = Stream.of( Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6) );Stream&lt;Integer&gt; outputStream = inputStream.flatMap((childList) -&gt; childList.stream()); flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。 filter 留下偶数 123Integer[] sixNums = &#123;1, 2, 3, 4, 5, 6&#125;;Integer[] evens =Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new); // &#123;2, 4, 6&#125; 把单词挑出来 1234List&lt;String&gt; output = reader.lines().flatMap(line -&gt; Stream.of(line.split(REGEXP))).filter(word -&gt; word.length() &gt; 0).collect(Collectors.toList()); forEach forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。 打印姓名（forEach 和 pre-java8 的对比） 12345678910// Java 8roster.stream() .filter(p -&gt; p.getGender() == Person.Sex.MALE) .forEach(p -&gt; System.out.println(p.getName()));// Pre-Java 8for (Person p : roster) &#123; if (p.getGender() == Person.Sex.MALE) &#123; System.out.println(p.getName()); &#125;&#125; 对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。 但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。 另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的： 12stream.forEach(element -&gt; doOneThing(element));stream.forEach(element -&gt; doAnotherThing(element)); 相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。 peek 对每个元素执行操作并返回一个新的 Stream 123456Stream.of(\"one\", \"two\", \"three\", \"four\") .filter(e -&gt; e.length() &gt; 3) .peek(e -&gt; System.out.println(\"Filtered value: \" + e)) .map(String::toUpperCase) .peek(e -&gt; System.out.println(\"Mapped value: \" + e)) .collect(Collectors.toList()); forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。 findFirst 这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。 Optional 的两个用例123456789101112131415161718192021String strA = \" abcd \", strB = null;print(strA);print(\"\");print(strB);getLength(strA);getLength(\"\");getLength(strB);public static void print(String text) &#123; // Java 8 Optional.ofNullable(text).ifPresent(System.out::println); // Pre-Java 8 if (text != null) &#123; System.out.println(text); &#125; &#125;public static int getLength(String text) &#123; // Java 8return Optional.ofNullable(text).map(String::length).orElse(-1); // Pre-Java 8// return if (text != null) ? text.length() : -1; &#125;; 在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。 reduce 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或Integer sum = integers.reduce(0, Integer::sum);也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。 reduce 的用例123456789101112// 字符串连接，concat = \"ABCD\"String concat = Stream.of(\"A\", \"B\", \"C\", \"D\").reduce(\"\", String::concat); // 求最小值，minValue = -3.0double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); // 求和，sumValue = 10, 有起始值int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum);// 求和，sumValue = 10, 无起始值sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get();// 过滤，字符串连接，concat = \"ace\"concat = Stream.of(\"a\", \"B\", \"c\", \"D\", \"e\", \"F\"). filter(x -&gt; x.compareTo(\"Z\") &gt; 0). reduce(\"\", String::concat); 上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。 limit/skip limit 和 skip 对运行次数的影响12345678910111213141516171819202122public void testLimitAndSkip() &#123; List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 10000; i++) &#123; Person person = new Person(i, \"name\" + i); persons.add(person); &#125;List&lt;String&gt; personList2 = persons.stream().map(Person::getName).limit(10).skip(3).collect(Collectors.toList()); System.out.println(personList2);&#125;private class Person &#123; public int no; private String name; public Person (int no, String name) &#123; this.no = no; this.name = name; &#125; public String getName() &#123; System.out.println(name); return name; &#125;&#125; 结果为: 1234567891011name1name2name3name4name5name6name7name8name9name10[name4, name5, name6, name7, name8, name9, name10] 这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。 limit 和 skip 对 sorted 后的运行次数无影响 12345678List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) &#123; Person person = new Person(i, \"name\" + i); persons.add(person); &#125;List&lt;Person&gt; personList2 = persons.stream().sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).limit(2).collect(Collectors.toList());System.out.println(personList2); 结果为: 123456789name2name1name3name2name4name3name5name4[stream.StreamDW$Person@816f27d, stream.StreamDW$Person@87aac27] 即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。 sorted对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化： 优化：排序前进行 limit 和 skip 1234567List&lt;Person&gt; persons = new ArrayList(); for (int i = 1; i &lt;= 5; i++) &#123; Person person = new Person(i, \"name\" + i); persons.add(person); &#125;List&lt;Person&gt; personList2 = persons.stream().limit(2).sorted((p1, p2) -&gt; p1.getName().compareTo(p2.getName())).collect(Collectors.toList());System.out.println(personList2); 结果:123name2name1[stream.StreamDW$Person@6ce253f1, stream.StreamDW$Person@53d8d10a] 当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。 min/max/distinctmin 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。 找出最长一行的长度 1234567BufferedReader br = new BufferedReader(new FileReader(\"c:\\\\SUService.log\"));int longest = br.lines(). mapToInt(String::length). max(). getAsInt();br.close();System.out.println(longest); 找出全文的单词，转小写，并排序 123456789List&lt;String&gt; words = br.lines(). flatMap(line -&gt; Stream.of(line.split(\" \"))). filter(word -&gt; word.length() &gt; 0). map(String::toLowerCase). distinct(). sorted(). collect(Collectors.toList());br.close();System.out.println(words); MatchStream 有三个 match 方法，从语义上说： allMatch：Stream 中全部元素符合传入的 predicate，返回 true anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true 它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。对清单 13 中的 Person 类稍做修改，加入一个 age 属性和 getAge 方法。 使用 Match 123456789101112List&lt;Person&gt; persons = new ArrayList();persons.add(new Person(1, \"name\" + 1, 10));persons.add(new Person(2, \"name\" + 2, 21));persons.add(new Person(3, \"name\" + 3, 34));persons.add(new Person(4, \"name\" + 4, 6));persons.add(new Person(5, \"name\" + 5, 55));boolean isAllAdult = persons.stream(). allMatch(p -&gt; p.getAge() &gt; 18);System.out.println(\"All are adult? \" + isAllAdult);boolean isThereAnyChild = persons.stream(). anyMatch(p -&gt; p.getAge() &lt; 12);System.out.println(\"Any child? \" + isThereAnyChild); 结果：12All are adult? falseAny child? true 自己生成流Stream.generate 通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。 生成 10 个随机整数 123456Random seed = new Random();Supplier&lt;Integer&gt; random = seed::nextInt;Stream.generate(random).limit(10).forEach(System.out::println);//Another wayIntStream.generate(() -&gt; (int) (System.nanoTime() % 100)).limit(10).forEach(System.out::println); Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。 自实现 Supplier 1234567891011Stream.generate(new PersonSupplier()).limit(10).forEach(p -&gt; System.out.println(p.getName() + \", \" + p.getAge()));private class PersonSupplier implements Supplier&lt;Person&gt; &#123; private int index = 0; private Random random = new Random(); @Override public Person get() &#123; return new Person(index++, \"StormTestUser\" + index, random.nextInt(100)); &#125;&#125; 结果:12345678910StormTestUser1, 9StormTestUser2, 12StormTestUser3, 88StormTestUser4, 51StormTestUser5, 22StormTestUser6, 28StormTestUser7, 81StormTestUser8, 51StormTestUser9, 4StormTestUser10, 76 Stream.iterate iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推。 生成一个等差数列 1Stream.iterate(0, n -&gt; n + 3).limit(10). forEach(x -&gt; System.out.print(x + \" \"));. 输出结果为:10 3 6 9 12 15 18 21 24 27 与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。 用 Collectors 来进行 reduction 操作 按照年龄归组12345678Map&lt;Integer, List&lt;Person&gt;&gt; personGroups = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.groupingBy(Person::getAge));Iterator it = personGroups.entrySet().iterator();while (it.hasNext()) &#123; Map.Entry&lt;Integer, List&lt;Person&gt;&gt; persons = (Map.Entry) it.next(); System.out.println(\"Age \" + persons.getKey() + \" = \" + persons.getValue().size());&#125; 上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出： 1234567Age 0 = 2Age 1 = 2Age 5 = 2Age 8 = 1Age 9 = 1Age 11 = 2...... 按照未成年人和成年人归组12345Map&lt;Boolean, List&lt;Person&gt;&gt; children = Stream.generate(new PersonSupplier()). limit(100). collect(Collectors.partitioningBy(p -&gt; p.getAge() &lt; 18));System.out.println(\"Children number: \" + children.get(true).size());System.out.println(\"Adult number: \" + children.get(false).size()); 输出结果为:12Children number: 23 Adult number: 77 在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。 结束语总之，Stream 的特性可以归纳为： 不是数据结构 它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。 它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。 所有 Stream 的操作必须以 lambda 表达式为参数 不支持索引访问 你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。 很容易生成数组或者 List 惰性化 很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。 Intermediate 操作永远是惰性化的。 并行能力 当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。 可以是无限的 集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://aschouas.com/categories/JAVA/"}],"tags":[{"name":"技术研究","slug":"技术研究","permalink":"http://aschouas.com/tags/技术研究/"}]},{"title":"Hexo搭建博客教程","date":"2017-05-17T01:53:18.000Z","path":"2017/05/17/Hexo搭建博客教程/","text":"喜欢吃水蜜桃 以前用的博客都丢失了，真的好气啊，所以一直有想法搭建一个自己的博客。所以利用hexo+github搭建了本地博客,用于分享一些心得，记录一些有意思的事情。在这个过程中，遇到了很多问题，在此记录一些配置和遇到的问题。 Hexo搭建博客教程准备 下载 node.js 并安装,默认安装 npm 下载安装 git，并与 github 关联,详情见上篇文章 下载安装 hexo，打开 cmd 运行 npm install -g hexo 本地搭建Hexo静态博客 本地新建一个文件夹,比如 MyBlog 在MyBlog文件夹中右击运行 Git Bash Here , 输入 hexo init —生成hexo模板,需要科学上网 生成完模板之后，输入 npm install,这里值得注意的是，在 windows 下,会出现npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@^1.0.0 ， fsevents@^1.0.0 是 mac osx 系统的。 —忽略 最后运行 hexo server —然后在浏览器输入 http://localhost:4000 就可以看到博客基本搭好了 将博客与github关联 在 Github 上创建名字为 XXX.github.io 的项目，XXX为自己的 github 用户名。 打开本机文件夹 MyBlog 内的 _config.yml 文件 1234deploy:type: gitrepository: ssh://git@github.com/aschouas/aschouas.github.iobranch: master 运行 npm install hexo-deployer-git –save 运行 hexo g/genrnate（本地生成静态文件） 运行 hexo d/deloye (将本地静态文件推送至 github) 到此在浏览器输入 aschouas.github.io 便可访问自己的博客啦 绑定域名一不小心申请了一个域名，于是我将 github 博客绑定到自己域名 域名解析设置 添加 CNAME文件 配置完域名解析后，进入博客目录，在 source 目录下新建 CNAME 文件(没有任何后缀)，写入域名，如：aschouas.com 更新博客内容更新文章 在 MyBolg 文件夹下运行 hexo new &quot;you need blog name&quot;,会在 source/_posts 文件夹下生成一个 *.md 文件 编辑该文件 （遵守 MarkDown 规则）, 可以使用 MarkDown 编辑器 修改起始字段 tilte 文章的标题 date 创建日期 （文件的创建日期 ） updated 修改日期 （ 文件的修改日期） comments 是否开启评论 true tags 标签 categories 分类 permalink url中的名字（文件名） 创建新的文章的时候,起始字段比较少，每次都要加，很麻烦 只需要在 scaffolds/post.md 文件夹中添加你需要的字段即可 编写正文 (MarkDown) 执行 hexo clean (清除本地编译文件 /Public) 执行 hexo g (生成本地静态文件 /Public) 执行 hexo d (将本地静态文件推送至 github) MarkDwon语法斜体和粗体 使用 和 * 表示斜体和粗体，格式如下： *斜体*， **粗体** 渲染效果： 这是 斜体，这是 粗体 。 分级标题 使用 === 表示一级标题，使用 — 表示二级标题，格式如下： 12345这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题 你也可以选择在行首加#号表示不同级别的标题 (H1-H6)，格式如下： 123456# H1## H2### H3#### H4##### H5###### H6 分割线在单独的一行使用 * 或者 — 表示分割线 删除线使用 ~~ 表示删除线. 超链接 插入文字超链接的格式如下 ： 1[链接文字](链接地址 \"链接标题\") 插入图片超链接的格式如下： 1![图片说明](图片链接 \"图片标题\") 引用视频则直接插入iframe代码： &lt;script src=\"/js/youtube-autoresizer.js\"&gt;&lt;/script&gt; &lt;iframe width=\"640\" height=\"360\" src=\"https://www.youtube.com/embed/HfElOZSEqn4\" frameborder=\"0\" allowfullscreen&gt;&lt;/iframe&gt; 更换主题 我们首先要 获取主题 进入 themes 目录下： 下载主题 git clone https://github.com/iissnan/hexo-theme-next.git（主题的地址） 打开__config.yml文件，将themes修改为next（下载到的主题文件夹的名字） hexo g hexo d 如果需要个性化配置 报错解决 Deployer not found: git 当编辑__config.yml文件，将type: git设置完成后，运行hexo g 报错：git not found 解决方案：可以在MyBlog目录下运行: npm install hexo-deployer-git –save。 permission denied 当执行: hexo deploy 报错时，把__config.yml中的github连接形式从ssh改成http。 当在themes目录下载主题时，报错。 将该目录只读属性取消。 genrnate 报错 检查_config.yml配置中，键值对冒号后面是否已经预留了一个半角空格。 ERROR Plugin load failed: hexo-generator-feed npm install hexo-generator-feed npm install hexo-generator-feed --save fatal: The remote end hung up unexpectedly git config https.postBuffer 524288000 git config http.postBuffer 524288000 git config ssh.postBuffer 524288000 hero d推送的内容有问题 首先检查下.deploy_git文件夹下的.git文件是否存在，此.git文件指定了hexo d时推送public文件夹，而不是所有的内容。如果此.git文件不存在，则会出现推送内容错误。用npm install hexo-deployer-git –save生成的.deploy_git不包含.git文件，因此正确的做法是.deploy_git文件夹也需要备份，然后再用npm install hexo-deployer-git –save更新一下其内容即可。 异地同步博客内容node_modules public scaffolds source themes _config_yml db.json package.json .deploy_git 以上为利用hexo生成的博客全部内容，那么当我们执行hexo d时，正真被推送到github上的又有哪些内容呢？ 我们可以看下github上的tengzhangchao.github.io项目，发现里面只有Public目录下的内容。也就是说，我们博客上呈现的内容，其实就是public下的文件内容。那么这个Pulic目录是怎么生成的呢？ 一开始hexo init的时候是没有public目录的，而当我们运行hexo g命令时，public目录被生成了，换句话说hexo g命令就是用来生成博客文件的（会根据_config.yml，source目录文件以及themes目录下文件生成）。同样当我们运行hexo clean命令时，public目录被删除了。 好了，既然我们知道了决定博客显示内容的只有一个Public目录，而public目录又是可以动态生成的，那么其实我们只要在不同电脑上同步可以生成Public目录的文件即可。 以下文件以及目录是必须要同步的： source themes _config.yml db.json package.json .deploy_git 同步的方式有很多种，可以每次更新后都备份到一个地址。我采用github去备份，也就是新建一个项目用来存放以上文件，每次更新后推送到github上，用作备份同步。 同步完必须的文件后，怎么再其他电脑上也可以更新博客呢？ 前提假设我们现在配置了一台新电脑，里面没有安装任何有关博客的东西，那么我们开始吧： 下载node.js并安装（官网下载安装），默认会安装npm。 下载安装git（官网下载安装） 下载安装hexo。方法：打开cmd 运行npm install -g hexo（要科学上网） 新建一个文件夹，如MyBlog -进入该文件夹内，右击运行git，输入：hexo init（生成hexo模板，要科学上网) 我们重复了一开始搭建博客的步骤，重新生成了一个新的模板，这个模板中包含了hexo生成的一些文件。 git clone 我们备份的项目，生成一个文件夹，如：MyBlogData 将MyBlog里面的node_modules、scaffolds文件夹复制到MyBlogData里面。 做完这些，从表面上看，两台电脑上MyBlogData目录下的文件应该都是一样的了。那么我们运行hexo ghexo d试试，如果会报错，则往下看。 这是因为.deploy_git没有同步，在MyBlogData目录内运行:npm install hexo-deployer-git –save后再次推送即可 总结流程：当我们每次更新MyBlog内容后，先利用hexo将public推送到github，然后再将其余必须同步的文件利用git推送到github。","categories":[{"name":"教程","slug":"教程","permalink":"http://aschouas.com/categories/教程/"}],"tags":[{"name":"技术研究","slug":"技术研究","permalink":"http://aschouas.com/tags/技术研究/"}]},{"title":"Git远程关联github仓库","date":"2017-05-16T07:39:52.000Z","path":"2017/05/16/git远程关联github/","text":"树欲静而风不止 github远程关联本地git 首先需要在本地安装git https://git-scm.com/downloads 如果已经成功在本地安装git,又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，那就需要用到SSH Key，github拿到了你的公钥就会知道内容是你推送的,前提是你要有github账号. 本地配置用户名和邮箱打开[gitBash] git config --global user.name &quot;你的用户名&quot; git config --global user.email &quot;你的邮箱&quot; 生成ssh key ssh-keygen -t rsa -C &quot;你的邮箱&quot; 需要注意的是这个地方会有三次需要你输入密码，为了方便直接回车略过!之后会在控制台看到ssh key 被保存存到了 ../.ssh/id_rsa.pub 这个文件中，找到这个文件复制key 打开github，进入Settings sshkey 添加成功之后 测试一下 ssh -T git@github.com 如果出现 You&#39;ve successfully 则表示配置成功 创建远程仓库并与本地关联 创建远程仓库 首先是在右上角点击进入创建界面： 接着输入远程仓库名: 点击 Create repository 就创建好了。 创建本地仓库 新建文件夹，/test 定位到该文件下 执行 git init 将远程仓库和本地仓库关联起来 先到Github上复制远程仓库的SSH地址： 注意SSH的地址格式是这样开头的： git@github.com 运行 git remote add origin 你复制的地址 如果你在创建 repository 的时候，加入了 README.md 或者 LICENSE ，那么 github 会拒绝你的 push 。你需要先执行 git pull origin master(远程本地仓库同步)。 git status 查看当前仓库状态 git add . 将所有文件添加到仓库(也可单个文件名) git commit -m &quot;message&quot; 提交 message–本次提交备注 git push origin master:master 推送到远程仓库 —-与上一步效果相同—–执行 git push -u origin master 将本地仓库上传至Github的仓库并进行关联 到此，已经完成关联! 以后想在commit后同步到Github上，只要直接执行 git push 就可以了","categories":[{"name":"教程","slug":"教程","permalink":"http://aschouas.com/categories/教程/"}],"tags":[{"name":"技术研究","slug":"技术研究","permalink":"http://aschouas.com/tags/技术研究/"}]},{"title":"有感","date":"2017-05-15T06:45:33.000Z","path":"2017/05/15/我的第一篇文章/","text":"天气真的不错 123456789101112131415161718家中无房又无钱，生活本就艰谁知那小情侣，蛮横不讲理总秀恩爱朋友圈，还到空间发照片无缘无故我就被戳痛心间我婉转跟他来抱怨，惨被他羞辱要多读诗篇我劝告他们对狗要轻虐，反被他们牵手当着面嘲笑了一百遍！一百遍！最后无奈只能拉黑屏蔽换取清静空间没有那小情侣，生活乐无边狂吃到市前，散步在江边五杀虐泉感觉自己无法无天谁知那小情侣，实在太阴险得知此情形，竟拥吻在人前，欢声笑语又好似神仙幸得身体健，不然魂归天，徒留悲愤遗恨人间为求不见面，唯有加班加点独处办公间一边拼事业，一边寻姻缘发誓要让女友现，恩爱牵手去逛街从此我是好人记心间，期待神气虐狗的那一天。","categories":[{"name":"今天没下雨","slug":"今天没下雨","permalink":"http://aschouas.com/categories/今天没下雨/"}],"tags":[{"name":"心情","slug":"心情","permalink":"http://aschouas.com/tags/心情/"}]}]